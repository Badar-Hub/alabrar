import dotenv from 'dotenv';
import jwt from 'jsonwebtoken';
import { logger } from '~/utils';
import { status } from '~/constants';
import { LoginSessionSchema } from '~/schemas/LoginSession';

dotenv.config();

export const auth = async (req, res, next) => {
  //Codes that we might return coming from status
  const { UNAUTHROIZED, PRE_CONDITION_FAILED, BAD_REQUEST, FORBIDDEN } = status;

  // Expecting authorization field in header starting bearer followed by space and token
  if (
    !req.headers.authorization ||
    !req.headers.authorization.toLowerCase().includes('bearer')
  )
    return res.json({
      success: false,
      error: {
        code: UNAUTHROIZED,
        message: 'Access Denied! No Token Provided',
      },
    });

  try {
    //Splitting authorization based on space to get token
    const accessToken = req.headers.authorization.split(' ')[1];

    //Extracting the payload(data) from token
    const { payload: payLoad } = jwt.decode(accessToken, { complete: true });

    //Making sure token is not expired
    if (new Date(payLoad.exp * 1000) < new Date(Date.now())) {
      return res.json({
        success: false,
        error: {
          code: PRE_CONDITION_FAILED,
          message: 'Token Expired',
        },
      });
    }

    //Checking the token is generated by us
    const inDataBase = await LoginSessionSchema.findOne(
      { access_token: accessToken },
      { _id: 1 },
    );

    if (!inDataBase || !inDataBase._id) {
      return res.json({
        success: false,
        error: {
          code: FORBIDDEN,
          message: 'Invalid Token',
        },
      });
    }

    //Extracting user object from the payload for future use in any api call as long as it supports req object
    req.user = payLoad.user;
    next();
  } catch (e) {
    //Log in case of any abnormal crash
    logger('error', 'Error:', e.message);
    return res.json({
      success: false,
      error: {
        code: BAD_REQUEST,
        message: 'Invalid Token',
      },
    });
  }
};
